#include "TensorLines.hh"

#include "TensorProductBezierTriangles.hh"
#include "TensorCoreLinesEvaluator.hh"
#include "TensorTopologyEvaluator.hh"
#include "ParallelEigenvectorsEvaluator.hh"

#include <Eigen/Eigenvalues>
#include <Eigen/LU>

#include <boost/range/algorithm/min_element.hpp>
#include <boost/range/algorithm_ext/insert.hpp>
#include <boost/optional.hpp>

#include <stack>
#include <queue>
#include <iterator>
#include <complex>
#include <type_traits>

using namespace cpp_utils;

namespace
{
using namespace tl;

/**
 * Representative Solution in a cluster of similar solutions
 */
template <typename Evaluator>
struct ClusterRepr
{
    std::size_t cluster_size;
    Evaluator eval;
};


/**
 * Cluster all triangles in a list that are closer than a given distance
 *
 * @param cands List of candidates generated by parallelEigenvectorSearch()
 * @param epsilon Maximum distance of triangles in a cluster
 *
 * @return List of clusters (each cluster is a list of candidates)
 */
template <typename CandList>
std::vector<CandList>
clusterTris(const CandList& cands, double epsilon)
{
    auto classes = std::vector<CandList>{};
    for(const auto& t : cands)
    {
        classes.push_back({t});
    }

    auto has_close_elements = [&](const CandList& c1,
                                  const CandList& c2) {
        if(c1 == c2) return false;
        for(const auto& t1 : c1)
        {
            for(const auto& t2 : c2)
            {
                if(distance(t1, t2) <= epsilon)
                {
                    return true;
                }
            }
        }
        return false;
    };

    auto changed = true;
    while(changed)
    {
        changed = false;
        for(auto it = std::begin(classes); it != std::end(classes); ++it)
        {
            auto jt = it;
            ++jt;
            for(; jt != std::end(classes); ++jt)
            {
                if(has_close_elements(*it, *jt))
                {
                    it->insert(std::end(*it), std::begin(*jt), std::end(*jt));
                    jt = classes.erase(jt);
                    --jt;
                    changed = true;
                }
            }
        }
    }
    return classes;
}


/**
 * @brief Select representative solutions for each cluster.
 * @details For each cluster, the solution candidate with the smallest error
 *      estimate is chosen as a representative. Also returns the number of
 *      elements in the cluster.
 *
 * @param clusters Vector of vectors of Evaluators representing solution
 *     clusters as produced by clusterTris().
 * @return A cluster representative for each input cluster.
 */
template <typename Evaluator>
std::vector<ClusterRepr<Evaluator>>
findRepresentatives(const std::vector<std::vector<Evaluator>>& clusters)
{
    static_assert(is_evaluator_v<Evaluator>,
                  "findRepresentatives requires a valid Evaluator!");
    auto result = std::vector<ClusterRepr<Evaluator>>{};
    for(const auto& c : clusters)
    {
        using namespace boost;
        using namespace boost::adaptors;
        result.push_back(
                {c.size(),
                 *min_element(c, [](const auto& c1, const auto& c2) {
                     return c1.error() < c2.error();
                 })});
    }
    return result;
}


/**
 * @brief Compute context info for representatives
 * @details Computes global point position, eigenvalue order, presence of other
 *      imaginary eigenvalues, and packs into result list together with point
 *      position, eigenvector direction, eigenvalues.
 *
 * @param representatives TriPairs selected by findRepresentatives()
 * @param s_interp First tensor field on the triangle
 * @param t_interp Second tensor field on the triangle
 * @param tri Spatial triangle
 * @return List of TLPoints with context info
 */
PointList
computeContextInfoPEV(
        const std::vector<
            ClusterRepr<ParallelEigenvectorsEvaluator>>& representatives,
        const TensorInterp& s_interp,
        const TensorInterp& t_interp,
        const Triangle& tri)
{
    auto points = PointList{};
    points.reserve(representatives.size());

    for(const auto& r : representatives)
    {
        const auto& pos_tri = r.eval.tris().pos_tri;
        const auto& dir_tri = r.eval.tris().dir_tri;

        auto result_center = pos_tri({1. / 3., 1. / 3., 1. / 3.});
        auto result_dir = dir_tri({1. / 3., 1. / 3., 1. / 3.}).normalized();

        // We want to know which eigenvector of each tensor field we have
        // found (i.e. corresponding to largest, middle, or smallest
        // eigenvalue)
        // Therefore we explicitly compute the eigenvalues at the result
        // position and check which ones the found eigenvector direction
        // corresponds to.
        // @todo: make this step optional

        auto s = s_interp(result_center);
        auto t = t_interp(result_center);

        // Get eigenvalues from our computed direction
        auto s_real_eigv = (s * result_dir).dot(result_dir);
        auto t_real_eigv = (t * result_dir).dot(result_dir);

        // Compute all eigenvalues using Eigen
        auto s_eigvs = s.eigenvalues().eval();
        auto t_eigvs = t.eigenvalues().eval();

        // Find index of eigenvalue that is closest to the one we computed
        using Vec3c = decltype(s_eigvs);
        auto s_closest_index = Vec3d::Index{0};
        (s_eigvs - Vec3c::Ones() * s_real_eigv)
                .cwiseAbs()
                .minCoeff(&s_closest_index);

        auto t_closest_index = Vec3d::Index{0};
        (t_eigvs - Vec3c::Ones() * t_real_eigv)
                .cwiseAbs()
                .minCoeff(&t_closest_index);

        // Find which of the (real) eigenvalues ours is
        auto count_larger_real = [](double ref,
                                    const std::complex<double>& val) {
            if(val.imag() != 0) return 0;
            if(std::abs(ref) >= std::abs(val.real())) return 0;
            return 1;
        };
        auto s_order = s_eigvs.unaryExpr([&](const std::complex<double>& val) {
                                  return count_larger_real(
                                          s_eigvs[s_closest_index].real(), val);
                              })
                               .sum();
        auto t_order = t_eigvs.unaryExpr([&](const std::complex<double>& val) {
                                  return count_larger_real(
                                          t_eigvs[t_closest_index].real(), val);
                              })
                               .sum();

        points.push_back(
                TLPoint{tri(result_center),
                         ERank(s_order),
                         ERank(t_order),
                         result_dir,
                         s_real_eigv,
                         t_real_eigv,
                         s_eigvs.sum().imag() != 0,
                         t_eigvs.sum().imag() != 0,
                         r.cluster_size,
                         (pos_tri[1] - pos_tri[0]).norm(),
                         (dir_tri[1] - dir_tri[0]).norm(),
                         0.});
    }
    return points;
}


PointList
computeContextInfoTCL(
        const std::vector<ClusterRepr<TensorCoreLinesEvaluator>>& representatives,
        const TensorInterp& t_interp,
        const TensorInterp& tx_interp,
        const TensorInterp& ty_interp,
        const TensorInterp& tz_interp,
        const Triangle& tri)
{
    auto points = PointList{};
    points.reserve(representatives.size());

    for(const auto& r : representatives)
    {
        const auto& pos_tri = r.eval.tris().pos_tri;
        const auto& dir_tri = r.eval.tris().dir_tri;

        auto result_center = pos_tri({1. / 3., 1. / 3., 1. / 3.});
        auto result_dir = dir_tri({1. / 3., 1. / 3., 1. / 3.}).normalized();

        // We want to know which eigenvector of each tensor field we have
        // found (i.e. corresponding to largest, middle, or smallest
        // eigenvalue)
        // Therefore we explicitly compute the eigenvalues at the result
        // position and check which ones the found eigenvector direction
        // corresponds to.
        // @todo: make this step optional

        auto t = t_interp(result_center);
        auto tx = tx_interp(result_center);
        auto ty = ty_interp(result_center);
        auto tz = tz_interp(result_center);
        auto dt = (tx * result_dir[0] + ty * result_dir[1] + tz * result_dir[2])
                          .eval();

        // Get eigenvalues from our computed direction
        auto t_real_eigv = (t * result_dir).dot(result_dir);
        auto dt_real_eigv = (dt * result_dir).dot(result_dir);

        // Compute all eigenvalues using Eigen
        auto t_eigvs = t.eigenvalues().eval();
        auto dt_eigvs = dt.eigenvalues().eval();

        // Find index of eigenvalue that is closest to the one we computed
        using Vec3c = decltype(t_eigvs);
        auto t_closest_index = Vec3d::Index{0};
        (t_eigvs - Vec3c::Ones() * t_real_eigv)
                .cwiseAbs()
                .minCoeff(&t_closest_index);

        auto dt_closest_index = Vec3d::Index{0};
        (dt_eigvs - Vec3c::Ones() * dt_real_eigv)
                .cwiseAbs()
                .minCoeff(&dt_closest_index);

        // Find which of the (real) eigenvalues ours is
        auto count_larger_real = [](double ref,
                                    const std::complex<double>& val) {
            if(val.imag() != 0) return 0;
            if(std::abs(ref) >= std::abs(val.real())) return 0;
            return 1;
        };
        auto t_order = t_eigvs.unaryExpr([&](const std::complex<double>& val) {
                                  return count_larger_real(
                                          t_eigvs[t_closest_index].real(), val);
                              })
                               .sum();
        auto dt_order =
                dt_eigvs.unaryExpr([&](const std::complex<double>& val) {
                            return count_larger_real(
                                    dt_eigvs[dt_closest_index].real(), val);
                        })
                        .sum();

        // det( (NablaT*R1)*R  ,  (NablaT*R2)*R ,  R )
        auto r2 = Vec3d::Random().normalized().eval();
        while(result_dir.cross(r2).norm() < 0.1)
        {
            r2 = Vec3d::Random().normalized().eval();
        }
        auto r1 = result_dir.cross(r2).normalized().eval();
        r2 = r1.cross(result_dir).normalized().eval();
        auto scale = t.operatorNorm();
        auto stability = std::log(std::abs(
                (Mat3d{} << ((tx * r1[0] + ty * r1[1] + tz * r1[2])
                             * result_dir)
                                    / scale,
                 ((tx * r2[0] + ty * r2[1] + tz * r2[2]) * result_dir) / scale,
                 result_dir)
                        .finished()
                        .determinant()));

        points.push_back(
                TLPoint{tri(result_center),
                         ERank(t_order),
                         ERank(dt_order),
                         result_dir,
                         t_real_eigv,
                         dt_real_eigv,
                         t_eigvs.sum().imag() != 0,
                         dt_eigvs.sum().imag() != 0,
                         r.cluster_size,
                         (pos_tri[1] - pos_tri[0]).norm(),
                         (dir_tri[1] - dir_tri[0]).norm(),
                         stability});
    }
    return points;
}


PointList computeContextInfoTopo(
        const std::vector<ClusterRepr<TensorTopologyEvaluator>>& representatives,
        const Triangle& tri)
{
    auto points = PointList{};
    points.reserve(representatives.size());

    for(const auto& r : representatives)
    {
        const auto& pos_tri = r.eval.tris().pos_tri;

        auto result_center = pos_tri({1. / 3., 1. / 3., 1. / 3.});

        points.push_back(
                TLPoint{tri(result_center),
                         ERank::First,
                         ERank::First,
                         Vec3d::Zero(),
                         0,
                         0,
                         false,
                         false,
                         r.cluster_size,
                         (pos_tri[1] - pos_tri[0]).norm(),
                         0,
                         0});
    }
    return points;
}


/**
 * @brief Perform the recursive root search using an evaluator.
 * @details Performs a breadth-first recursive search for solutions of the
 *      starting evaluator. Terminates when all solutions have been found or
 *      when more than @a max_candidates are in the queue. In the latter case,
 *      @c boost::none is returned.
 *
 * @param start_ev Starting evaluator
 * @param max_candidates Maximum number of triangles produced during subdivision
 *     before early termination
 * @param num_splits Optional output parameter for storing the number of split
 *     operations performed
 * @param max_level Optional output parameter for storing the maximum
 *     subdivision level reached
 * @return A vector of solution candidates represented by Evaluators at the lowest
 *      subdivision level, or boost::none if the search was terminated early.
 */
template <typename Evaluator>
boost::optional<std::vector<Evaluator>>
rootSearch(const Evaluator& start_ev,
           std::size_t max_candidates,
           uint64_t* num_splits = nullptr,
           uint64_t* max_level = nullptr)
{
    static_assert(is_evaluator_v<Evaluator>,
                  "rootSearch requires a valid Evaluator!");

    auto work_lst = std::queue<Evaluator>{};
    work_lst.push(start_ev);
    auto result = std::vector<Evaluator>{};

    while(!work_lst.empty())
    {
        if(work_lst.size() > max_candidates) return boost::none;
        auto ev = work_lst.front();
        work_lst.pop();
        if(num_splits) *num_splits += 1;
        if(max_level && *max_level < ev.splitLevel())
        {
            *max_level = ev.splitLevel();
        }

        switch(ev.eval())
        {
            case Result::Split:
                for(const auto& p : ev.split())
                {
                    work_lst.push(p);
                }
                break;
            case Result::Accept:
                result.push_back(ev);
                break;
            case Result::Discard:
                break;
        }
    }

    return result;
}


/**
 * Search for parallel eigenvector intersections with a triangle.
 *
 * @param s First tensor field (linear on a triangle)
 * @param t Second tensor field (linear on a triangle)
 * @param tri Physical location of the triangle
 * @param tolerance Error tolerance for subdivision
 * @param max_candidates Maximum number of triangles produced during subdivision
 *     before early termination
 * @param num_splits Optional output parameter for storing the number of split
 *     operations performed
 * @param max_level Optional output parameter for storing the maximum
 *     subdivision level reached
 * @return A vector of all found solution candidates and a vector of the
 *     rough eigenvector directions that resulted in early termination
 */
std::pair<std::vector<ParallelEigenvectorsEvaluator>, std::vector<Vec3d>>
parallelEigenvectorSearch(const TensorInterp& s,
                          const TensorInterp& t,
                          const Triangle& tri,
                          double tolerance,
                          std::size_t max_candidates,
                          uint64_t* num_splits = nullptr,
                          uint64_t* max_level = nullptr)
{
    auto result = std::vector<ParallelEigenvectorsEvaluator>{};
    // Stores directions for which the search was terminated because of
    // too many splits
    auto failed_dirs = std::vector<Vec3d>{};

    auto compute_tri = [&](const Triangle& r) {
        auto start_ev = ParallelEigenvectorsEvaluator(
                {tri, r}, s, t, {tolerance});
        auto solutions =
                rootSearch(start_ev, max_candidates, num_splits, max_level);
        if(solutions)
        {
            boost::insert(
                    result,
                    result.end(),
                    solutions.value());
        }
        else
        {
            failed_dirs.push_back(r({1./3, 1./3, 1./3}));
        }
    };

    // Four triangles covering hemisphere
    auto dir_tris = std::array<Triangle, 4>{
            Triangle{{Vec3d{1, 0, 0}, Vec3d{0, 1, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{0, 1, 0}, Vec3d{-1, 0, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{-1, 0, 0}, Vec3d{0, -1, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{0, -1, 0}, Vec3d{1, 0, 0}, Vec3d{0, 0, 1}}}};

    for(const auto& tri : dir_tris)
    {
        for(const auto& t : tri.split())
        {
            compute_tri(t);
        }
    }

    return {result, failed_dirs};
}



/**
 * Search for tensor core line intersections with a triangle.
 *
 * @param t Tensor field (linear on a triangle)
 * @param dt derivatives of the tensor field (constant on a triangle)
 * @param tri Physical location of the triangle
 * @param tolerance Error tolerance for subdivision
 * @param max_candidates Maximum number of triangles produced during subdivision
 *     before early termination
 * @param num_splits Optional output parameter for storing the number of split
 *     operations performed
 * @param max_level Optional output parameter for storing the maximum
 *     subdivision level reached
 * @return A vector of all found solution candidates and a vector of the
 *     rough eigenvector directions that resulted in early termination
 */
std::pair<std::vector<TensorCoreLinesEvaluator>, std::vector<Vec3d>>
tensorCoreLinesSearch(const TensorInterp& t,
                         const std::array<TensorInterp, 3>& dt,
                         const Triangle& tri,
                         double tolerance,
                         std::size_t max_candidates,
                         uint64_t* num_splits = nullptr,
                         uint64_t* max_level = nullptr)
{
    auto result = std::vector<TensorCoreLinesEvaluator>{};
    // Stores directions for which the search was terminated because of
    // too many splits
    auto failed_dirs = std::vector<Vec3d>{};

    auto compute_tri = [&](const Triangle& r) {
        auto start_ev = TensorCoreLinesEvaluator(
                {tri, r}, t, dt, {tolerance});
        auto solutions =
                rootSearch(start_ev, max_candidates, num_splits, max_level);
        if(solutions)
        {
            boost::insert(result, result.end(), solutions.value());
        }
        else
        {
            failed_dirs.push_back(r({1. / 3, 1. / 3, 1. / 3}));
        }
    };

    auto dir_tris = std::array<Triangle, 4>{
            Triangle{{Vec3d{1, 0, 0}, Vec3d{0, 1, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{0, 1, 0}, Vec3d{-1, 0, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{-1, 0, 0}, Vec3d{0, -1, 0}, Vec3d{0, 0, 1}}},
            Triangle{{Vec3d{0, -1, 0}, Vec3d{1, 0, 0}, Vec3d{0, 0, 1}}}};

    for(const auto& tri : dir_tris)
    {
        for(const auto& t : tri.split())
        {
            compute_tri(t);
        }
    }

    return {result, failed_dirs};
}


/**
 * Search for degenerate line intersections with a triangle.
 *
 * @param t Tensor field (linear on a triangle)
 * @param tri Physical location of the triangle
 * @param tolerance Error tolerance for subdivision
 * @param max_candidates Maximum number of triangles produced during subdivision
 *     before early termination
 * @param num_splits Optional output parameter for storing the number of split
 *     operations performed
 * @param max_level Optional output parameter for storing the maximum
 *     subdivision level reached
 * @return A vector of all found solution candidates and a vector of the
 *     rough eigenvector directions that resulted in early termination
 */
std::pair<std::vector<TensorTopologyEvaluator>, std::vector<Vec3d>>
tensorTopologySearch(const TensorInterp& t,
                     const Triangle& tri,
                     double tolerance,
                     std::size_t max_candidates,
                     uint64_t* num_splits = nullptr,
                     uint64_t* max_level = nullptr)
{
    auto start_ev = TensorTopologyEvaluator(
            {tri, Triangle{{Vec3d::Zero(), Vec3d::Zero(), Vec3d::Zero()}}},
            t,
            {tolerance});
    auto solutions =
            rootSearch(start_ev, max_candidates, num_splits, max_level);

    if(solutions)
    {
        return {solutions.value(), std::vector<Vec3d>{}};
    }
    else
    {
        return {std::vector<TensorTopologyEvaluator>{},
                std::vector<Vec3d>{1, Vec3d::Zero()}};
    }
}

} // namespace


namespace tl
{

TLResult findParallelEigenvectors(const std::array<Mat3d, 3>& s,
                                   const std::array<Mat3d, 3>& t,
                                   const std::array<Vec3d, 3>& x,
                                   const TLOptions& opts)
{
    auto start_tri =
            Triangle{{Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}}};

    auto st = TensorInterp{{s[0], s[1], s[2]}};
    auto tt = TensorInterp{{t[0], t[1], t[2]}};
    auto xt = Triangle{{x[0], x[1], x[2]}};

    auto num_splits = uint64_t{0};
    auto max_level = uint64_t{0};
    auto tris = parallelEigenvectorSearch(st,
                                          tt,
                                          start_tri,
                                          opts.tolerance,
                                          opts.max_candidates,
                                          &num_splits,
                                          &max_level);

    auto clustered_tris = clusterTris(tris.first, opts.cluster_epsilon);

    auto representatives = findRepresentatives(clustered_tris);

    return {computeContextInfoPEV(representatives, st, tt, xt),
            tris.second};
}


TLResult findParallelEigenvectors(const std::array<Mat3d, 3>& s,
                                   const std::array<Mat3d, 3>& t,
                                   const TLOptions& opts)
{
    return findParallelEigenvectors(
            s,
            t,
            {Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}},
            opts);
}


TLResult findTensorCoreLines(const std::array<Mat3d, 3>& t,
                                 const std::array<Mat3d, 3>& dt,
                                 const std::array<Vec3d, 3>& x,
                                 const TLOptions& opts)
{
    auto start_tri =
            Triangle{{Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}}};

    auto tt = TensorInterp{{t[0], t[1], t[2]}};
    auto tx = TensorInterp{{dt[0], dt[0], dt[0]}};
    auto ty = TensorInterp{{dt[1], dt[1], dt[1]}};
    auto tz = TensorInterp{{dt[2], dt[2], dt[2]}};
    auto xt = Triangle{{x[0], x[1], x[2]}};

    auto tolerance_scale = std::max({tt[0].operatorNorm(),
                                     tt[1].operatorNorm(),
                                     tt[2].operatorNorm()});

    auto num_splits = uint64_t{0};
    auto max_level = uint64_t{0};
    auto tris = tensorCoreLinesSearch(tt,
                                         {tx, ty, tz},
                                         start_tri,
                                         opts.tolerance*tolerance_scale,
                                         opts.max_candidates,
                                         &num_splits,
                                         &max_level);

    auto clustered_tris = clusterTris(tris.first, opts.cluster_epsilon);

    auto representatives = findRepresentatives(clustered_tris);

    return {computeContextInfoTCL(representatives, tt, tx, ty, tz, xt),
            tris.second};
}


TLResult findTensorCoreLines(const std::array<Mat3d, 3>& t,
                                 const std::array<Mat3d, 3>& dt,
                                 const TLOptions& opts)
{
    return findTensorCoreLines(
            t,
            dt,
            {Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}},
            opts);
}

TLResult findTensorTopology(const std::array<Mat3d, 3>& t,
                             const std::array<Vec3d, 3>& x,
                             const TLOptions& opts)
{
    auto start_tri =
            Triangle{{Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}}};

    auto tt = TensorInterp{{t[0], t[1], t[2]}};
    auto xt = Triangle{{x[0], x[1], x[2]}};

    auto tolerance_scale = std::max({tt[0].operatorNorm(),
                                     tt[1].operatorNorm(),
                                     tt[2].operatorNorm()});

    auto num_splits = uint64_t{0};
    auto max_level = uint64_t{0};
    auto tris = tensorTopologySearch(tt,
                                     start_tri,
                                     opts.tolerance * tolerance_scale,
                                     opts.max_candidates,
                                     &num_splits,
                                     &max_level);

    auto clustered_tris = clusterTris(tris.first, opts.cluster_epsilon);

    auto representatives = findRepresentatives(clustered_tris);

    return {computeContextInfoTopo(representatives, xt),
            tris.second};
}


TLResult findTensorTopology(const std::array<Mat3d, 3>& t,
                             const TLOptions& opts)
{
    return findTensorTopology(
            t,
            {Vec3d{1., 0., 0.}, Vec3d{0., 1., 0.}, Vec3d{0., 0., 1.}},
            opts);
}

} // namespace tl
