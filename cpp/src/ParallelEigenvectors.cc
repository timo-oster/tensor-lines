#include "ParallelEigenvectors.hh"

#include "BarycentricInterpolator.hh"

#include <Eigen/LU>
#include <Eigen/Eigenvalues>

#include <boost/optional/optional.hpp>

#include <iostream>
#include <algorithm>
#include <utility>
#include <array>
#include <map>
#include <queue>
#include <stack>

namespace
{

using namespace peigv;

/**
 * Coefficients of a cubic Bézier triangle
 */
using BCoeffs = std::array<double, 10>;

/**
 * Names for coefficients of a cubic Bézier triangle
 */
enum BezierIndices: int
{
    i300 = 0,
    i210,
    i201,
    i030,
    i120,
    i021,
    i003,
    i102,
    i012,
    i111
};

/**
 * Linear tensor field expressed in barycentric coordinates
 */
using TensorInterp = BarycetricInterpolator<Mat3d>;

/**
 * Triangle in 3d expressed in barycentric coordinates
 */
using Triangle = BarycetricInterpolator<Vec3d>;

/**
 * Aggregate representing a candidate solution for a parallel eigenvector point.
 *
 * Holds the triangle in direction space that contains the potential
 * eigenvector, and the triangle in barycentric coordinate space that contains
 * the potential eigenvector point.
 */
struct TriPair
{
    Triangle direction_tri;
    Triangle spatial_tri;

    friend bool operator==(const TriPair& tp1, const TriPair& tp2)
    {
        return tp1.direction_tri == tp2.direction_tri
                && tp1.spatial_tri == tp2.spatial_tri;
    }

    friend bool operator!=(const TriPair& tp1, const TriPair& tp2)
    {
        return !(tp1 == tp2);
    }
};

/**
 * List of parallel eigenvector point candidates
 */
using TriPairList = std::list<TriPair>;


/**
 * @brief (simplified) distance between two triangles
 * @details Computes smallest distance between two triangle corners
 */
double distance(const Triangle& t1, const Triangle& t2)
{
    return std::min({
        (t1.v1() - t2.v1()).norm(),
        (t1.v2() - t2.v1()).norm(),
        (t1.v3() - t2.v1()).norm(),
        (t1.v1() - t2.v2()).norm(),
        (t1.v2() - t2.v2()).norm(),
        (t1.v3() - t2.v2()).norm(),
        (t1.v1() - t2.v3()).norm(),
        (t1.v2() - t2.v3()).norm(),
        (t1.v3() - t2.v3()).norm()
    });
}


/**
 * Cluster all triangles in a list that are closer than a given distance
 *
 * @param tris List of candidates generated by parallelEigenvectorSearch()
 * @param epsilon Maximum distance of triangles in a cluster
 *
 * @return List of clusters (each cluster is a list of candidates)
 */
std::list<TriPairList>
clusterTris(const TriPairList& tris, double epsilon)
{
    auto classes = std::list<TriPairList>{};
    for(const auto& t: tris)
    {
        classes.push_back({t});
    }

    auto has_close_elements = [&](const TriPairList& c1, const TriPairList& c2)
    {
        if(c1 == c2) return false;
        for(const auto& t1: c1)
        {
            for(const auto& t2: c2)
            {
                if(distance(t1.spatial_tri, t2.spatial_tri) <= epsilon)
                {
                    return true;
                }
            }
        }
        return false;
    };

    auto changed = true;
    while(changed)
    {
        changed = false;
        for(auto it = std::begin(classes); it != std::end(classes); ++it)
        {
            auto jt = it;
            ++jt;
            for(; jt != std::end(classes); ++jt)
            {
                if(has_close_elements(*it, *jt))
                {
                    it->insert(std::end(*it), std::begin(*jt), std::end(*jt));
                    jt = classes.erase(jt);
                    --jt;
                    changed = true;
                }
            }
        }
    }
    return classes;
}


/**
 * Check if all coefficients are positive or negative
 *
 * @return 1 for all positive, -1 for all negative, 0 otherwise
 */
int sameSign(const BCoeffs& coeffs)
{
    if(std::all_of(std::begin(coeffs), std::end(coeffs),
                   [](double v){ return v > 0; }))
    {
        return 1;
    }
    if(std::all_of(std::begin(coeffs), std::end(coeffs),
                   [](double v){ return v < 0; }))
    {
        return -1;
    }
    return 0;
}


BCoeffs bezierCoefficients(const Mat3d& A,
                           const Mat3d& B,
                           const Mat3d& C)
{
    auto result = BCoeffs{};

    result[i300] = A.determinant();
    result[i030] = B.determinant();
    result[i003] = C.determinant();

    result[i210] = 1. / 3. * (
              (Mat3d{} << B.col(0), A.col(1), A.col(2)).finished().determinant()
            + (Mat3d{} << A.col(0), B.col(1), A.col(2)).finished().determinant()
            + (Mat3d{} << A.col(0), A.col(1), B.col(2)).finished().determinant()
            );

    result[i201] = 1. / 3. * (
              (Mat3d{} << C.col(0), A.col(1), A.col(2)).finished().determinant()
            + (Mat3d{} << A.col(0), C.col(1), A.col(2)).finished().determinant()
            + (Mat3d{} << A.col(0), A.col(1), C.col(2)).finished().determinant()
            );

    result[i120] = 1. / 3. * (
              (Mat3d{} << A.col(0), B.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), A.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), B.col(1), A.col(2)).finished().determinant()
            );

    result[i021] = 1. / 3. * (
              (Mat3d{} << C.col(0), B.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), C.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), B.col(1), C.col(2)).finished().determinant()
            );

    result[i102] = 1. / 3. * (
              (Mat3d{} << A.col(0), C.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), A.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), C.col(1), A.col(2)).finished().determinant()
            );

    result[i012] = 1. / 3. * (
              (Mat3d{} << B.col(0), C.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), B.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), C.col(1), B.col(2)).finished().determinant()
            );

    result[i111] = 1. / 6. * (
              (Mat3d{} << A.col(0), B.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << A.col(0), C.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), A.col(1), C.col(2)).finished().determinant()
            + (Mat3d{} << B.col(0), C.col(1), A.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), A.col(1), B.col(2)).finished().determinant()
            + (Mat3d{} << C.col(0), B.col(1), A.col(2)).finished().determinant()
            );

    return result;
}


std::array<BCoeffs, 3>
bezierCoefficients(const Mat3d& t1, const Mat3d& t2, const Mat3d& t3,
                   const Vec3d& r1, const Vec3d& r2, const Vec3d& r3)
{
    auto A = Mat3d{};
    A << t1 * r1, t2 * r1, t3 * r1;

    auto B = Mat3d{};
    B << t1 * r2, t2 * r2, t3 * r2;

    auto C = Mat3d{};
    C << t1 * r3, t2 * r3, t3 * r3;

    auto alpha_coeffs = bezierCoefficients(
            (Mat3d{} << r1, A.col(1), A.col(2)).finished(),
            (Mat3d{} << r2, B.col(1), B.col(2)).finished(),
            (Mat3d{} << r3, C.col(1), C.col(2)).finished());

    auto beta_coeffs = bezierCoefficients(
            (Mat3d{} << A.col(0), r1, A.col(2)).finished(),
            (Mat3d{} << B.col(0), r2, B.col(2)).finished(),
            (Mat3d{} << C.col(0), r3, C.col(2)).finished());

    auto gamma_coeffs = bezierCoefficients(
            (Mat3d{} << A.col(0), A.col(1), r1).finished(),
            (Mat3d{} << B.col(0), B.col(1), r2).finished(),
            (Mat3d{} << C.col(0), C.col(1), r3).finished());

    // auto denom_coeffs = bezierCoefficients(A, B, C);

    return {alpha_coeffs, beta_coeffs, gamma_coeffs};
}


boost::optional<Triangle> findEigenDir(const TensorInterp& s,
                                       const TensorInterp& t,
                                       double epsilon)
{
    auto tstck = std::stack<Triangle>{};

    tstck.push(Triangle{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
    tstck.push(Triangle{{0, 1, 0}, {-1, 0, 0}, {0, 0, 1}});
    tstck.push(Triangle{{-1, 0, 0}, {0, -1, 0}, {0, 0, 1}});
    tstck.push(Triangle{{0, -1, 0}, {1, 0, 0}, {0, 0, 1}});

    while(!tstck.empty())
    {
        auto tri = tstck.top();
        tstck.pop();

        // @todo: further speedup:
        // compute coefficients for alpha, beta, gamma on-demand while checking
        // for different signs. Might skip gamma if alpha and beta already have
        // different signs.
        auto s_coeffs = bezierCoefficients(
                s.v1(), s.v2(), s.v3(),
                tri.v1(), tri.v2(), tri.v3());

        auto s_alpha_sign = sameSign(s_coeffs[0]);
        auto s_beta_sign = sameSign(s_coeffs[1]);
        auto s_gamma_sign = sameSign(s_coeffs[2]);

        // different signs: parallel vectors not possible
        if(std::max({s_alpha_sign, s_beta_sign, s_gamma_sign})
           * std::min({s_alpha_sign, s_beta_sign, s_gamma_sign}) < 0)
        {
            continue;
        }

        auto t_coeffs = bezierCoefficients(
                t.v1(), t.v2(), t.v3(),
                tri.v1(), tri.v2(), tri.v3());

        auto t_alpha_sign = sameSign(t_coeffs[0]);
        auto t_beta_sign = sameSign(t_coeffs[1]);
        auto t_gamma_sign = sameSign(t_coeffs[2]);

        // different signs: parallel vectors not possible
        if(std::max({t_alpha_sign, t_beta_sign, t_gamma_sign})
           * std::min({t_alpha_sign, t_beta_sign, t_gamma_sign}) < 0)
        {
            continue;
        }

        // All same signs: parallel vectors possible
        if(std::abs(s_alpha_sign + s_beta_sign + s_gamma_sign) == 3
           && std::abs(t_alpha_sign + t_beta_sign + t_gamma_sign) == 3)
        {
            return tri;
        }

        // Small triangle and still not sure if parallel eigenvectors possible
        // or impossible: assume yes
        if((tri.v1() - tri.v2()).norm() < epsilon)
        {
            return tri;
        }

        auto tri_subs = tri.split();
        for(const auto& t: tri_subs)
        {
            tstck.push(t);
        }
    }
    return boost::none;
}


TriPairList parallelEigenvectorSearch(const TensorInterp& s,
                                      const TensorInterp& t,
                                      const Triangle& tri,
                                      double spatial_epsilon,
                                      double direction_epsilon)
{
    struct SubPackage
    {
        TensorInterp s;
        TensorInterp t;
        Triangle tri;
    };

    auto pque = std::queue<SubPackage>{};
    pque.push({s, t, tri});

    auto result = TriPairList{};

    while(!pque.empty())
    {
        auto pack = pque.front();
        pque.pop();

        auto dir = findEigenDir(pack.s, pack.t, direction_epsilon);

        if(!dir) continue;

        if((pack.tri.v1() - pack.tri.v2()).norm() < spatial_epsilon)
        {
            result.push_back({dir.value(), pack.tri});
            continue;
        }

        auto s_subs = pack.s.split();
        auto t_subs = pack.t.split();
        auto tri_subs = pack.tri.split();

        for(auto i: range(s_subs.size()))
        {
            pque.push({s_subs[i], t_subs[i], tri_subs[i]});
        }
    }

    return result;
}

} // namespace

namespace peigv
{

PointList findParallelEigenvectors(
        const Mat3d& s1, const Mat3d& s2, const Mat3d& s3,
        const Mat3d& t1, const Mat3d& t2, const Mat3d& t3,
        const Vec3d& p1, const Vec3d& p2, const Vec3d& p3,
        double spatial_epsilon, double direction_epsilon,
        double cluster_epsilon, double parallelity_epsilon)
{
    auto tri = Triangle{p1, p2, p3};

    auto start_tri = Triangle{Vec3d{1., 0., 0.},
                              Vec3d{0., 1., 0.},
                              Vec3d{0., 0., 1.}};

    auto s_interp = TensorInterp{s1, s2, s3};
    auto t_interp = TensorInterp{t1, t2, t3};

    auto tris = parallelEigenvectorSearch(
            s_interp, t_interp,
            start_tri, spatial_epsilon, direction_epsilon);
    auto clustered_tris = clusterTris(tris, cluster_epsilon);

    auto points = PointList{};

    for(const auto& c: clustered_tris)
    {
        const auto* min_angle_tri = &*(c.cbegin());
        auto min_sin = 1.;
        for(const auto& trip: c)
        {
            auto dir = trip.direction_tri(1./3., 1./3., 1./3.).normalized();
            auto center = trip.spatial_tri(1./3., 1./3., 1./3.);
            auto s = s_interp(center);
            auto t = t_interp(center);

            // std::cout << "Checking candidate point " << print(center)
                      // << "...";

            // compute error as sum of deviations from input direction
            // after multiplication with tensors
            auto ms = (s * dir).normalized().cross(dir.normalized()).norm()
                      + (t * dir).normalized().cross(dir.normalized()).norm();

            // check if the error measure is low enough to consider the point a
            // parallel eigenvector point
            if(ms > parallelity_epsilon)
            {
                // std::cout << "rejected with error " << ms << std::endl;
                continue;
            }

            // std::cout << "accepted with error " << ms << std::endl;

            if(ms < min_sin)
            {
                min_sin = ms;
                min_angle_tri = &trip;
            }
        }
        if(min_sin < 1.)
        {
            auto result_center =
                    min_angle_tri->spatial_tri(1./3., 1./3., 1./3.);
            auto result_dir =
                    min_angle_tri->direction_tri(1./3., 1./3., 1./3.)
                    .normalized();

            // We want to know which eigenvector of each tensor field we have
            // found (i.e. corresponding to largest, middle, or smallest
            // eigenvalue)
            // Therefore we explicitly compute the eigenvalues at the result
            // position and check which ones the found eigenvector direction
            // corresponds to.
            // @todo: make this step optional

            auto s = s_interp(result_center);
            auto t = t_interp(result_center);

            // Get eigenvalues from our computed direction
            auto s_real_eigv = (s * result_dir).dot(result_dir);
            auto t_real_eigv = (t * result_dir).dot(result_dir);

            // Compute all eigenvalues using Eigen
            auto s_eigvs = s.eigenvalues().eval();
            auto t_eigvs = t.eigenvalues().eval();

            // Find index of eigenvalue that is closest to the one we computed
            using vec3c = decltype(s_eigvs);
            auto s_closest_index = Vec3d::Index{0};
            (s_eigvs - vec3c::Ones() * s_real_eigv)
                    .cwiseAbs().minCoeff(&s_closest_index);

            auto t_closest_index = Vec3d::Index{0};
            (t_eigvs - vec3c::Ones() * t_real_eigv)
                    .cwiseAbs().minCoeff(&t_closest_index);

            // Find which of the (real) eigenvalues ours is
            auto count_larger_real = [](double ref,
                                         const std::complex<double>& val)
            {
                if(val.imag() != 0) return 0;
                if(std::abs(ref) >= std::abs(val.real())) return 0;
                return 1;
            };
            auto s_order = s_eigvs.unaryExpr(
                    [&](const std::complex<double>& val)
                    {
                        return count_larger_real(
                                s_eigvs[s_closest_index].real(), val);
                    }).sum();
            auto t_order = t_eigvs.unaryExpr(
                    [&](const std::complex<double>& val)
                    {
                        return count_larger_real(
                                t_eigvs[t_closest_index].real(), val);
                    }).sum();

            // std::cout << "Final Eigenvector point: "
            //           << print(result_center) << std::endl;
            // std::cout << "Final Eigenvector direction: "
            //           << print(result_dir) << std::endl;
            // std::cout << "Final S Eigenvalue: "
            //           << s_real_eigv << std::endl;
            // std::cout << "Final T Eigenvalue: "
            //           << t_real_eigv << std::endl;
            // std::cout << "Final S Matrix: \n" << s << std::endl;
            // std::cout << "Final T Matrix: \n" << t << std::endl;
            // auto errvec = Eigen::Matrix<double, 6, 1>{};
            // errvec.topRows<3>() = (s*result_dir).cross(result_dir);
            // errvec.bottomRows<3>() = (t*result_dir).cross(result_dir);
            // std::cout << "Error vector: \n" << errvec << std::endl;

            points.push_back({tri(result_center),
                              ERank(s_order),
                              ERank(t_order),
                              result_dir,
                              s_real_eigv,
                              t_real_eigv});
        }
    }
    return points;
}


PointList findParallelEigenvectors(
        const Mat3d& s1, const Mat3d& s2, const Mat3d& s3,
        const Mat3d& t1, const Mat3d& t2, const Mat3d& t3,
        double spatial_epsilon, double direction_epsilon,
        double cluster_epsilon, double parallelity_epsilon)
{
    return findParallelEigenvectors(
            s1, s2, s3, t1, t2, t3,
            Vec3d{1, 0, 0}, Vec3d{0, 1, 0}, Vec3d{0, 0, 1},
            spatial_epsilon, direction_epsilon,
            cluster_epsilon, parallelity_epsilon);
}

} // namespace peigv
